spring.application.name=auth-failure-generator
logging.level.com=trace
spring.cloud.function.definition=failuresSupplier

#broker
spring.kafka.properties.sasl.mechanism=PLAIN
spring.kafka.bootstrap-servers=pkc-4j8dq.southeastasia.azure.confluent.cloud:9092
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username='${KAFKA_USERNAME}' password='${KAFKA_PASSWORD}';
spring.kafka.properties.security.protocol=SASL_SSL
spring.cloud.stream.bindings.failuresSupplier-out-0.destination=auth-failure

#DB configuration POSTGRESQL
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.password=${PGSQL_PASSWORD}
spring.datasource.username=${PGSQL_USER}
spring.datasource.url=jdbc:postgresql://${PGSQL_HOST}:${PGSQL_PORT}/${PGSQL_DB}

#Hibernate configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect



#delay between generating of AuthFailuresDto in ms
spring.integration.poller.fixedDelay=100
#count of generating AuthFailuresDto (set 0 if you want infinite generation)
app.auth.failures.polling.count=30

#range for random choosing third octet of generated subnet (set wider range for a long distance analysis
app.auth.failures.min.subnet=140
app.auth.failures.max.subnet=150
#max range for random choosing of service names existed in DB (set 1 if you want each time the same service name)
app.auth.failures.max.service.range=10




